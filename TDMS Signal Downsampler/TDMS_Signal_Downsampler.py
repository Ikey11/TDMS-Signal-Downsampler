"""TDMS Signal Downsampler


Functions
---------
Retreves, decimates, and concatenates TDMS files generated by a Silixa iDAS v2
The script decimates three files at a time to avoid edge effects due to
low-pass filter associated with decimation.  The decimation factor must consist
of prime factors under 13 for efficiency. Output is in matlab file format.

Author
---------
Mason Becker

"""

# Imports
from numpy import empty, append  # Array processing
from scipy.signal import decimate  # Low-pass filter mechanics
from time import time  # Compilation time
from math import sqrt, ceil
import tkinter
from tkinter import filedialog  # Windows folder selection dialog

# Additional Functions
import plotlib as PL
import DataManager as DM

## Attempts to produce a unique factorization for input integer
def factorize(n):
    factors = []
    # even case
    while n % 2 == 0:
        factors.append(2)
        n = n / 2

    # odd case
    for i in range(3, int(sqrt(n)) + 1, 2):
        while(n % i == 0):
            factors.append(i)
            n = n / i
    
    # Catch remainder
    if n > 2:
        factors.append(int(n))

    return factors

## Runs Scipy's decimation command recursively using factorized intervals to fit the function's parameters
def sig_decimate(data, factors, order=8):
    print("Decimating...")
    reduced = decimate(data, factors[0], order, ftype='iir')
    print(reduced.shape)

    # Preform recursion in accordence with interval factors
    if len(factors) > 1:
        reduced = sig_decimate(reduced, factors = factors[1:], order=order) # Slice a factor off and run recursion
    return reduced

## Main Process
if __name__ == "__main__":
    tkinter.Tk().withdraw()  # Prevents empty tkinter window from appearing

    # Credits
    print("TDMS Signal Downsampler\nBy Mason Becker\n")

    while True:
    # Directory prompt
        print("Select folder:")

        folder_path = filedialog.askdirectory(initialdir=r"Input", title="Select TDMS Folder")
        print("Directory: {0}".format(folder_path))

        # Find each avaliable file in Input directory
        file = DM.get_filepaths(folder_path)
        # Ensure files exist
        if len(file) == 0:
            print("Error! Folder does not contain any TDMS data!\nPress Enter to continue...")
            input()
            continue
        else:
            # User confirmation
            print("Input:")
            for doc in file:
                print(doc)
            print("Total files: " + str(len(file)) + "\n")
            break

    # Specify file parameters
    FFproperties = DM.tdms_properties(file[0])  # First file properties in dictionary form
    while True:
        try:
            # Essential TDMS Data
            print("Sampling Frequency[Hz]: {0}  Channels: {1}".format(FFproperties["SamplingFrequency[Hz]"], float(FFproperties["MeasureLength[m]"]) / float(FFproperties["SpatialResolution[m]"])))
            # Decimation factor
            print("Decimate factor (Ensure number consists of prime factors under 13):")
            intervalConfig = int(input())
            factors = factorize(intervalConfig)
            # Display working method and present warnings
            print("Factors: {0}".format(factors))
            for factor in factors:
                if factor > 13:
                    print("Warning: decimation factor contains prime factors over 13, this may lead to an inaccurate output.")
                    print("Continue with decimation?\n1. Yes\n2. No")
                    if input() != '1':
                        raise Exception("Resetting...")
                    else:
                        break
            # Set channel limits
            print("Set channel limits?\n1. Yes\n2. No")
            if input() == '1':
                print("Set channel minimum:")
                CMin = int(input())
                print("Set channel maximum:")
                CMax = int(input())
            else:
                CMin = None
                CMax = None
            # Determine output type
            print("Output type:\n1. MatLab file\n2. MatLab file and interactable figure\n3. Interactable figure")
            outConfig = int(input())
            if outConfig > 3 or outConfig < 1:
                print("Invalid input, please try again...")
                continue
            # MatLab output configuration
            if outConfig == 1:
                ## Uncomment to enable saving the raw file (Warning: This will take a long time and
                ## may lead to a systemwise crash if system memory is insuffient. Use with caution)
                #print("Output Set to MatLab file!")
                #print("Compare raw and decimated data? [Warning: This may be very computationally taxing if used on a large set of data.]\n1. Yes\n2. No")
                #if input() != '1':
                #    keep_raw = False
                #else:
                #    keep_raw = True
                keep_raw = False
            # Configuration for interactable figure
            if outConfig > 1:
                if outConfig == 2 : print("Output Set to MatLab file and Interactable figure!")
                else : print("Output Set to Interactable figure!")
                #print("Compare raw and decimated data? [Warning: This may be very computationally taxing if used on a large set of data.]\n1. No\n2. Yes")
                #if input() != '2':
                keep_raw = False
                #print("Only outputting decimated data!")
                print("Return:\n1. Color plot\n2. Individual channel")
                if input() == '1':
                    color_chart = True
                else:
                    color_chart = False
                    print("Set figure channel:")
                    channel = int(input())
                #else:
                #    keep_raw = True
                #    print("Saving raw data for comparison!")
                #    print("Compare:\n1. Color plot\n2. Individual channels")
                #    if input() == '1':
                #        color_chart = True
                #    else:
                #        color_chart = False
                #        print("Set figure channel:")
                #        channel = int(input())
            break # End user input
        except TypeError: # Prevent crashes due to casting
            print("Invalid input!")
        except Exception as err: # For resetting the program
            print(err)
            print("Resetting...")

    starttime = time() # Begin timer
    # Iterates between each file
    for doc in range(len(file)):
        # Return progress
        print("File (" + str(doc) + "/" + str(len(file)) + ")")

        # Retreves tdms data
        if doc > 0:
            dataB = DM.tdms_read(file[doc - 1], CMin, CMax)
        data = DM.tdms_read(file[doc], CMin, CMax)
        if doc < len(file) - 1:
            dataA = DM.tdms_read(file[doc + 1], CMin, CMax)
        # Accumulates the 3 portions into one data set
        if doc == 0 and doc < len(file) - 1: # Only after
            data_sum = append(data, dataA, 1)
        elif doc > 0 and doc == len(file) - 1: # Only before
            data_sum = append(dataB, data, 1)
        elif doc > 0 and doc < len(file) - 1: # Before and after
            data_sum = append(dataB, append(data, dataA, 1), 1)
        else: # If only one file
            data_sum = data

        # Decimates with account to the specified data's neighbores
        reduce_data = sig_decimate(data_sum, factors)
        print(str(doc) + " decimated shape: " + str(reduce_data.shape))

        # Create data matrix
        if doc == 0:
            # Trim excess and append data
            matrix = reduce_data[:, 0 : ceil(data.shape[1]/intervalConfig)]
            if keep_raw: 
                raw_matrix = data
        else:
            # Trim excess and append data
            matrix = append(matrix, reduce_data[:, ceil(dataB.shape[1]/intervalConfig) : ceil(dataB.shape[1]/intervalConfig) + ceil(data.shape[1]/intervalConfig)], 1)
            if keep_raw: 
                raw_matrix = append(raw_matrix, data, 1)
    # Data analysis
    print("Time Spent: " + str(time() - starttime) + "s")
    print("Final matrix shape: " + str(matrix.shape))

    # Data export
    if outConfig < 3:
        DM.properties_save(FFproperties)
        DM.mat_save(matrix)
        if keep_raw:
            DM.mat_save(raw_matrix, 'Output/Out_Raw.mat')
    if outConfig > 1:
        # Desides what figure output
        if keep_raw: 
            if color_chart:
                PL.interactable_compairson(raw_matrix, matrix, intervalConfig)
            else:
                PL.direct_compare(raw_matrix, matrix, channel, 0, raw_matrix.shape[1], intervalConfig)
        else: 
            if color_chart:
                PL.waterfall_plot(matrix)
            else:
                PL.channel_plot(matrix, channel)